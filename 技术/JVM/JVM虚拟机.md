---
color: ""
---

# JDK体系结构与JVM整体架构
![[Pasted image 20250929105830.png]]


## JDK
- Java DevelopmentToolKit ：java开发工具包
- 包括：
	- JRE：java运行环境
	- 开发工具：编译器、调试器、javadoc等
- Javac：java编译器
	- 把java代码编译成字节码（.class）
	- 字节码在任何平台都可以运行  ---JVM

## JRE
- Java Runtime Environment：java运行时环境
- JRE由JVM、java运行时类库，动态链接库等组成
- 通过JVM将字节码解释为可执行的机器码



# JVM内部组成
- Java Virtual Machine：java虚拟机
	- 可以看做是一台抽象化的计算机，它有一套完整的体系架构，包括处理器、堆栈、寄存器等
- 在运行时环境，JVM会将Java字节码解释成机器码
	- 机器码和平台相关的（不同硬件环境、不同操作系统，产生的机器码不同），所以JVM在不同平台有不同的实现
	- JVM从软件层面屏蔽不同OS在底层硬件与指令上的区别
- *堆和方法区是所以线程共有的*
- *线程栈、本地方法栈、方法区是各线程私有的*

![[Pasted image 20250929132409.png]]


## 字节码执行引擎
- PC的值是通过字节码执行引擎动态修改的



## 栈（线程）
- 启动一个新线程，JVM都会为它分配一个java栈，一个pc
- 看字节码
```
javap -c A.class > A.txt
```


### 栈帧
- java以栈帧为单位保存线程的运行状态
- 栈帧的组成
	- ==局部变量表==
	- ==操作数栈==
	- ==动态链接==
		- 程序在运行过程中，将符号引用转变为直接引用
			- 符号引用：一个方法test，调用这个方法【a.test】
			- 直接引用：我们在代码中调用方法，要去找这个方法的代码（都在方法区），**这个方法在方法区的入口地址就叫直接引用**
	- ==方法出口== 
		- 就是这个方法调用结束后，上层调用方继续在哪执行


### 堆和栈的关系
- 栈中是一个个线程，线程中会有一个个变量，如果这个变量是new的对象，这个栈中变量存的就是堆中对象的地址
	- eg：假如我的Math类中的main方法中new了一个math对象，那main栈帧中的局部变量表中会有个math变量，这个变量存的是在堆中这个math对象的地址



## 方法区（元空间）
- 存常量、静态变量、类信息
- **对象的静态变量也是在堆中new出来的，方法区存放的是堆对象的引用/指针**




## 本地方法栈
- 本地方法：用native修饰的方法是本地方法，本地方法不是用java写的



## 堆

### 年轻代、老年代
- 堆内存分年轻代（1/3）、老年代（2/3）

![[Pasted image 20250929160129.png]]

- 年轻代
	- 组成
		- Eden区（伊甸园）（8/10）
			- 所有新创建的对象首先在这里分配内存
			- 当Eden区内存不足时，会触发一次Minor GC
		- Survivor区（幸存者区）（1/10，1/10)
			- 分为两块：S0 和 S1
			- 他们的角色在每次Minor GC后都会交换
	- 对象在年轻代的旅程
		1. 新建对象：新对象被分配Eden区
		2. Eden区满：当Eden区再次被填满时，会触发一次Minor GC
			- 首先，标记Eden区和一个S区中所有存活的对象
			- 然后，将这些存活的对象**复制**到另一个空的Survivor区（To区）
			- 同时，会为这些存活的对象“年龄”加1（对象头中有一个计数器）
			- 最后，清空Eden区和刚才使用的From区
		3. Survivor区晋升
			- 每次Minor GC后，存活的对象会在S0和S1之间来回复制
			- 当一个对象的年龄增长到一定程度（默认是15，可通过 `-XX:MaxTenuringThreshold` 参数调整）时，它就会被**晋升**到老年代
		    - 另外，如果在Minor GC时，Survivor区放不下所有存活的对象，多出来的对象也会**直接晋升**到老年代
		    - Survivor区无法容纳的**大对象**（如很长的数组）也可能直接进入老年代
- 老年代
	- 存放的对象
		- 从年轻代晋升过来的对象
		- **大对象**： 如果对象非常大（比如一个巨大的数组），可能会绕过年轻代，直接在老年代分配，以避免在Eden和Survivor区之间进行昂贵的内存复制。
		- 在有些情况下（如在G1收集器中），当Survivor区放不下Minor GC后的存活对象时，一部分对象会直接进入老年代。
	- 垃圾回收
		- 当老年代的内存空间也被占满时，会触发 **Major GC**。
		- Major GC通常会伴随着一次 **Full GC**，即对整个堆（包括年轻代和老年代）以及方法区（元空间）进行垃圾回收。
		- **Full GC 的代价非常高**，会导致“Stop-The-World”（STW），即所有应用线程都会暂停，直到GC完成。因此，应尽量避免频繁的Full GC。
		- 老年代通常使用 **标记-整理** 或 **标记-清除** 算法，因为这些区域的对象存活率高，复制算法的成本太大。



### GC
#### Minor GC
- 专门清理JVM中年轻代内存区域的垃圾回收过程
- 触发时机：当​**​Eden区​**​的内存空间被新创建的对象填满时，JVM就会触发一次Minor GC
- 执行过程（复制-清除）
	1. **标记 （Mark）​**​：垃圾回收器会暂停所有应用线程（这个过程称为“Stop-The-World”），然后从GC Roots（如静态变量、局部变量表等）开始，标记出Eden区和当前正在使用的Survivor区（比如S0）中所有​**​存活的对象​**​。
	2. ​**​复制 （Copy）​**​：将所有存活的对象​**​复制​**​到另一个空的Survivor区（比如S1）。同时，这些存活对象的“年龄”会加1（每经历一次Minor GC，年龄就+1）。
	3. ​**​清理 （Sweep）​**​：然后，直接​**​清空​**​整个Eden区和刚才使用的那个Survivor区（S0）。此时，S1就成为了新的“From Survivor区”。
	4. ​**​年龄检查​**​：在复制的过程中，如果某个对象的年龄超过了设定的阈值（例如15），它就会被​**​晋升（Promote）​**​ 到​**​老年代​**​。



#### Major GC
- 专门清理JVM中老年代内存区域的垃圾回收过程
- 触发时机
	- ​**​老年代空间不足​**​：这是最常见的原因。当尝试将一个对象从年轻代晋升（Promote）到老年代时，如果发现​**​老年代剩余空间不足以存放该对象​**​，JVM就会触发一次Major GC来腾出空间。
	- ​**​空间分配担保失败​**​：在发生Minor GC之前，JVM会检查老年代的​**​连续可用空间​**​是否大于年轻代中​**​所有对象的总大小​**​（这是一个非常悲观的估计）。
	    - 如果大于，则说明即使这次Minor GC后所有年轻代的对象都存活下来（最坏情况），老年代也装得下，可以​**​担保​**​Minor GC是安全的。
	    - 如果小于，JVM会检查是否设置了-`XX：-HandlePromotionFailure`参数（JDK 6 Update 24之后，规则有变化，但逻辑类似）。如果担保失败，JVM不会冒险进行Minor GC，而是​**​直接触发一次Major GC​**​，先清理老年代，然后再进行Minor GC。
	- ​**​显式调用System.gc()​**​：建议JVM进行垃圾回收，这很可能会触发一次Major GC或Full GC（取决于JVM实现和垃圾回收器）。
	- ​**​大对象直接进入老年代​**​：如果创建了一个非常大的对象（比如一个大数组），而年轻代放不下，这个对象会直接尝试在老年代分配。如果老年代也没有足够的连续空间，则会触发Major GC。
- 执行过程（标记清除）
	- **​标记-清除 （Mark-Sweep）​**​：
	    1. ​**​标记​**​：从GC Roots开始，标记出所有​**​存活的对象​**​。
	    2. ​**​清除​**​：遍历整个老年代，回收所有​**​未被标记​**​的对象所占用的空间。
	        - ​**​缺点​**​：会产生​**​内存碎片​**​。清除后，可用空间是不连续的，当以后需要分配较大对象时，可能无法找到足够的连续内存，从而不得不提前触发另一次GC。
	- ​**​标记-整理 （Mark-Compact）​**​：
	    1. ​**​标记​**​：与“标记-清除”算法相同。
	    2. ​**​整理​**​：将所有​**​存活的对象​**​都向内存空间的一端​**​移动​**​，然后直接​**​清理掉边界以外的所有内存​**​。
	        - ​**​优点​**​：避免了内存碎片问题。
	        - ​**​缺点​**​：移动对象需要更新引用地址，开销更大，暂停时间（Stop-The-World）通常也更长。****




